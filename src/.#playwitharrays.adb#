with Ada.Text_IO;     use Ada.Text_IO;

package body playWithArrays with SPARK_Mode => On is

   function play (Table: T_Table; Table_2: T_Table) return T_Table is
      res : T_Table (Table'First .. Table'Last) := (others => 0);
   begin
      if (Table'Length - 1) = (Table_2'Length - 1) and Table'First = Table_2'First and
      res'First = 0  and Table'Last = Table_2'Last then

         if Table'First = Table'Last then
            res(0) := Table(0);

            return res;
         else
            for J in res'Range loop
               pragma Loop_Invariant (Table'First = Table_2'First );

               if J rem 2 = 0 then
                  res(J) := Table(J);
               else
                  res(J) := Table_2(J);
               end if;
            end loop;

         end if;

      end if;
         return res;
   end play;

   --Este metodo se podría hacer en una linea "return play(Table_2,Table);"
   --Pero haremos un bucle while para practicar las herramientas spark
   function playInverse (Table: T_Table; Table_2: T_Table) return T_Table is
      res : T_Table (Table'First .. Table'Last);
      Temp : Natural := Table'First;
   begin
      res := Table_2;
      if (Table'Length - 1) = (Table_2'Length - 1) and Table'First = Table_2'First and
      res'First = 0  and Table'Last = Table_2'Last then
         if Table'First = Table'Last then
            res(0) := Table(0);
            return res;
         else
            while Temp < Table'Last loop
               if Temp = 2147483647 then
                  return res;
               end if;
               --controlamos la salida del bucle
               pragma Loop_Variant (Increases => Temp + 1);
               --le idicamos que los pares no seran modificados.
               pragma Loop_Invariant (Temp <= res'Last);

               pragma Loop_Invariant
                 (if Temp rem 2 = 0 then res(Temp) <= res(Temp));

               if Temp rem 2 /= 0 then
                  res(Temp) := Table(Temp);
               end if;
               if Temp < 2147483647 then
                  Temp := Temp + 1;
               end if;
            end loop;
         end if;

      end if;
      return res;
   end playInverse;


   function playArrayResultInverse (Table: T_Table; Table_2: T_Table) return T_Table is
      res : T_Table := play(Table,Table_2);
      def : T_Table (Table'First .. Table'Last) := (others => 0);
      begin
      if res'Length = def'Length and res'First = def'First then
         for J in def'First .. def'Last loop
            pragma Loop_Invariant (J>=0);
            def(J) := res(res'Last - J);
         end loop;
      end if;
      return def;
   end playArrayResultInverse;

end playWithArrays;
